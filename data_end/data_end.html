<!DOCTYPE HTML PUBLIC
    "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- style and html organization taken from
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0480r0.html -->
<head>
   <title>data_end</title>

   <style>
      p {text-align:justify}
      li {text-align:justify}
      blockquote.note {
         background-color:#E0E0E0;
         padding-left: 15px;
         padding-right: 15px;
         padding-top: 1px;
         padding-bottom: 1px;
      }
      ins {color:#00A000}
      del {color:#A00000}
      th { scope: col; text-align: left }
      th, td { border-bottom: 1px solid #ddd; }
   </style>
</head>
<body>

<address align=right>
Document number: XXXX
<br/>
<br/>
<a href="mailto:mzeren@vmware.com">Mark Zeren</a><br/>
2016-11-NN<br/>
</address>
<hr/>
<h1 align=center>data_end</h1>

<h2>Introduction</h2>
<p>
While adding range-based for support for a custom container I noticed that GCC
4.8 missed an "obvious" optimization. I manually enabled the optimization by
implementing "<code>vector::data_end()</code>" in terms of <code>vector</code>'s
internal details.
</p>
<p>
This raised the question: Should the standard containers
provide <code>data_end()</code>, not only to enable optimizations, but also for
symmetry with <code>data()</code>?
</p>
<p>
The conclusion that I came to was "No". Read on to see why.
</p>
<a name="Background"></a><h2>Background</h2>
<p>
The custom type, let's call it Container, contained a vector, was always heap
allocated, and was always referenced by pointer. A null pointer to a Container
was logically equivalent to an empty container. To support range-based for I
started with the obvious namespace-scoped <code>begin()</code> and
<code>end()</code> functions:
<pre>
   <code>
      Item *begin(Container *c) {
        return c ? c->_vector.data() : nullptr;
      }
      Item *end(Container *c) {
        return c ? c->_vector.data() + c->_vector.size() : nullptr;
      }
   </code>
</pre>
</p>This met our functional requirements and interacted well with existing code.
</p>
<p>
However, examining the generated machine code I noticed that
my <code>end()</code> was implemented in terms of <code>
load,load,subtract,add</code> when it could have been a single <code>load</code>
of the vector's internal pointer to <em>end</em>. The indirection through a
pointer appears to have blocked the "obvious" optimization. If I changed the
code to iterate over a <em>reference</em> to a Container the expected
optimization appears, but unfortunately that is not compatible with our code
base.
</p>

<a name="Code_Generation_with_std_vector"></a><h3>Code Generation with
std::vector</h3>
<p>
I reduced my code to a simple example and examined the binaries generated by
GCC, Clang, Intel, and Microsoft compilers. I used three standard library
implementations: libstdc++, libc++ and Visual C++'s STL. The following table
summarizes the results:
</p>
<table>
   <tr>
      <th/>
      <th>libstdc++</th>
      <th>msvc STL</th>
      <th>libc++</th>
   </tr>
   <tr>
      <th>gcc 4.9+</th>
      <td>same</td>
      <td>N/A</td>
      <td>N/A</td>
   </tr>
   <tr>
      <th>gcc 4.8</th>
      <td>better</td>
      <td>N/A</td>
      <td>N/A</td>
   </tr>
   <tr>
      <th>clang 3.9</th>
      <td>better</td>
      <td>not tested</td>
      <td>better</td>
   </tr>
   <tr>
      <th>icc</th>
      <td>better</td>
      <td>not tested</td>
      <td>better</td>
   </tr>
   <tr>
      <th>msvc15</th>
      <td>N/A</td>
      <td>better</td>
      <td>not tested</td>
   </tr>
</table>
<p>
"same" indicates that the generated code is the same with and without a
"native" <code>data_end()</code>
</p>
<p>
"better" indicates that generated code improved with a
native <code>data_end()</code>.
</p>
<p>
GCC 4.9 and up find the optimization without <code>data_end()</code>. Other
compilers still generate better code with <code>data_end()</code>.
Significantly, my project will soon be moving from GCC 4.8 to GCC 6.
</p>

<a name="Other_Containers"></a><h3>Other Containers</h3>
<p>
Other containers that provide <code>data()</code> include <code>array</code>,
<code>basic_string</code>, and <code>basic_string_view</code>.
For <code>array</code>, <code>data_end()</code> provides no code generation
advantage. All three STLs implement <code>basic_string</code>
and <code>basic_string_view</code> in terms of a pointer and a count, once again
providing no advantage for <code>data_end</code>.
</p>

<a name="Conclusion"></a><h2>Conclusion</h2>
<p>
While emulating <code>vector::data_end()</code> provided some immediate benefit
for my project, we can expect that benefit to fade as compilers improve.
Additionally, it is unlikely that adding <code>data_end()</code>
to <code>array</code>, <code>basic_string</code>,
or <code>basic_string_view</code> will ever provide any advantage.
</p>
<p>
Thus, the limited value of <code>data_end()</code> does not justify an addition
to the standard library.
</p>
<a name="Appendix_Code"></a><h2>Appendix: Code</h2>
My testing used the following reproduction case:
<pre>
  <code>
    #include &lt;vector&gt;
    #include &lt;cstdio&gt;

    using namespace std;

    template&lt;class T&gt;
    struct Internals : vector&lt;T&gt; {
      T *data_end() {
    #if defined FASTER &amp;&amp; defined __GLIBCXX__
        // _M_impl is from a protected base class.
        return this-&gt;_M_impl._M_finish;
    #elif defined FASTER &amp;&amp; defined _MSC_VER
        return this-&gt;_Mylast();
    #elif defined FASTER &amp;&amp; defined(_LIBCPP_VERSION)
        struct Helper :
          __vector_base&lt;T, typename vector&lt;T&gt;::allocator_type&gt; {
          static T *data_end(Helper* helper) { return helper-&gt;__end_; }
        };
        return Helper::data_end(reinterpret_cast&lt;Helper*&gt;(this));
    #else
        return this-&gt;data() + this-&gt;size();
    #endif
      }
    };

    template&lt;class T&gt;
    T *data_end(std::vector&lt;T&gt;&amp; vec) {
      return static_cast&lt;Internals&lt;T&gt;&amp;&gt;(vec).data_end();
    }

    struct C { vector&lt;int&gt; _data; };

    static int *begin(C *c) {
      return c ? c-&gt;_data.data() : nullptr;
    }

    static int *end(C *c) {
      return c ? data_end(c-&gt;_data) : nullptr;
    }

    #ifdef _MSC_VER
    __declspec(noinline)
    #endif
    void example(C *c) {
      for (int i : c) { printf("%d", i); }
    }

    int main() {
      return 0;
    }
  </code>
</pre>

<p>
Play with this code in the <a href=
"https://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQAGAOgHZOBgoUICMpAFYgxqAA4E8dAM6U0AWxl52AeVoBhBM1rAOAck4mAlKUWoArsWSmApACYAzHlrJWtrAGonN10AN0xkImJA7CdOAEFXDy8ff0DdZEUCfFQomPi420VPYD9aZlVMRRlmRz8M9ECAIVzcgkx1VmZW1O9mRUU/ABUcuIziW3C/AEl6TGJS1n6QP1DwklSht2wA3ia4v0G/ACp0TuYAfUxadAgLbd349zwqPywqT0x0PwAxWIYB7AASgEXAA2Vwgl6YN60D5%2BM5nADiABlJg1dAANdHw3L7fYAejxcIAsmc8O0/Hh%2BlRiKhVH5mH4ZDTWuFYQAjXqYPw9PrcHG44iYAj2Wh%2BAgISkAWiiZxJZJkrG4srO0MpCEazXcmFYT0h0NhPz%2BgOBYNBeven1lDF0ZwAaoD%2BftBcK5mKJYppZtZQBPDoZG4auIJbW614W76/f5A8Hg80w65nFFogAKybtgIYky0ADkLI7agQxhMABLamSzPwgfP7eErCJnDmKTDrUhi73l0rlZZhCLrKIgEBsVioFj1gjt5ubO7VgudPDIA7HU4XK4QUuscvEQ5%2BBBl2a3Jw7PzOkU7vfET3YeGXdBnRrbAAi%2BcPT7c91xx6Fp/Xm4HJwI5w3hAgqeK0xBMkKZwsBkqQ/rMhxRBA4qUhYeZvpqbjak2%2BYnq6yEelE/7MDcwING6UpRIUABemABuhQZalcTz8i%2BzS8K%2B9wtG0CqdJOaR%2Bv0GzRHEAxHERK7XHUA51msQRCbGKwHjs/K4aKGRzsgUG9AQqTTGB8yKH2mwxpsECKdw4lAWhnHsc0IyFuMBB%2BLodzdqskRBKBURwkR96sfReSxOp8gLqBRxspgwCeBALmHMgSnvp%2BLqigugRfNyl5nERFmnCRSy0LYrAboWgbxLZQb2RpFL0EcQGxfF057Elp6pW46WWauyCZURtz5YVxUeTZT4VQ8HhUK8xLWumAK5PCWDeJUYQQLQqCeDqMJ5gxmFMVQuTBKtnyYAAHmUCq0fVCX8jQxB%2BBAYV4JW3IJYyxCgVQECuC4rgAKz1C4Litng1mPmxw2BWFqjMNFl1NapficKVrFxJYpCsCAJjfSYpC0OjIhY6g6O6K4TQuGRNj2DUCR46QBDo%2BYqGkAA1lIAAc3AiC4AAsIIsyzIIgu4ACcIic99IKo%2BjnNYzjZj4%2BjWPKJwNN0yjcCwEgagaOwZAUBAmuaLMKAdEYbjC6QbysGBygQGyKukGynjMMQ3p22o5T0DorAu7LpD4IK4R4KEyiy1YND0EwbAcDw/DCLHAjSHICi0MHkpaP0koAOpDn4kp1IED7IMTxMiCIOd1DqbL5xXhek8TOdyAggrMOgigo2jGPS3bBMmFTfgAO6EAgfhHXzkogpz3LG8UbjcIL7NY7TIdWMzLg8G4bggm4HPfbw7jfZwIKCxLJhS6QqhSAI2Nd/L1hcMrIekGriAoLSWuzOQKivwbxBG4YwCm2IC2VtKC2x9g7UoztXa0ndgQT23tzC%2BzwP7eQQcVahzoIwFg7AuB8DjnHBO8glDoxzg%2BQ0UYc5pxzlnIqZdMj5xriTBoJdaHoArlXPAbIGF10lA3Ju6A27o0xlfH23de4D3FMPUe49J5/z8DPOe1NF702XiAFwIhuDfTcCzQWgsWa8BBN9FwO89HH1PjLBB3cFZ3yUarGAz99baw/nrL%2B2sQDzmQCIXg5tNDAJtnbcBTt4FYzdpcWBtAvZ2z9j2QOFQ0HmwwRHbB0c8GxwIUnYOFD07UNYCw%2BhRdSYlwER3YRFj0ZiMHpIkEY8J7uL8J4heaCVGr24Ck4QnNTGdxETfRW996aPzsRADWLj366wcYbdxnjvGW1mNbUBCCAmQJ9iEj24SgmIOQTE4OfSw6YMjjgmOrT46kFkIQ5OxDJSkMjMaVOWTs6SlznQtwBd8lMNLkUoR5i5Y93cKXcRQ8R5VOkbU%2BpvTLBNJ4IcwQ7T25mOviYKxSsbEM3bi4TppT4WgoZqEYghQ6AgE5kAA%3D%3D"
>Compiler Explorer</a>.
</p>
</body>
</html>
