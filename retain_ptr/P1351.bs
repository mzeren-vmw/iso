<pre class='metadata'>
Title: Implementation experience with intrusive smart pointers
Status: P
Shortname: D1351
Group: WG21
Revision: 0
Editor: Mark Zeren, VMware, mzeren@vmware.com
Date: 2018-11-26
Audience: LEWGI
Audience: LEWG
Abstract: Provide feedback for [[P0468R1]] based on experience with intrusive smart pointers at VMware.
URL: http://wg21.link/P1351
Markup Shorthands: markdown yes
Default Highlight: C++
</pre>

# Introduction

This document provides an experience report on unse of intrusive smart
pointers at VMware. The intent is to inform the discussion of
[[P0468R1]].

At VMware we have a relatively widely used intrusive pointer template
class. For purposes of this discussion, let's call it `vm_ptr`. The
implementation of `vm_ptr` is a derivative of `boost::intrusive_ptr`.
There are a couple of varriances around extension points, etc., but
for this disucssion the key difference from `intrusive_ptr` is that
*lvalues* of `vm_ptr` implicitly convert to `T*`.

## `vm_ptr` Partial Synopsis

The following summarizes the member functions relevant to this paper
(names are changed):

<xmp>
template<typename T>
class vm_ptr {
public:
  vm_ptr();
  vm_ptr(nullptr_t);
  vm_ptr(T*);                       // Not explicit. Retains.
  vm_ptr& operator=(T*);            // Retains.
  ...
  operator T*() const &;            // Implicit for lvalues.
  operator T*() const && = delete;  // Deleted for rvalues.
  ...
  T *get() const;  // Explicit cast. "Yellow flag" to reviewers.
  ...
  void adopt(T*);  // Adopt. "Red flag" to reviewers.
  T *release();    // Release. "Red flag" to reviewers.
};
</xmp>

# Intrusive is Different

Peter Dimov summarized this nicely in a private email thread:
<blockquote>

Intrusively-counted smart pointers are qualitatively different from
`shared_ptr`, with the most important difference being that conversion
from raw pointer is safe and does the right thing. That is, if you
have `shared_ptr<T> p1, p2` and you do `p1 = p2.get()` that's a
disaster, but for `intrusive_ptr` it just works.

</blockquote>

# `vm_ptr` vs. `shared_ptr`

`vm_ptr` is more efficient than `shared_ptr` for the typical use case.
Replacing shared_ptr with vm_ptr generates better code. `shared_ptr`
has has overhead:

* Interior pointer support requires that each `shared_ptr` instance
  contain *two* pointers. One T* and one pointer to the control block.
  `vm_ptr` has only one pointer since the control block is embedded in
  T*.

* `weak_ptr` support requires that the control block manage *two*
  reference counts. `vm_ptr` does not provide weak reference counting,
  but it also does not preclude it. We have types that are managed by
  `vm_ptr` and which also support weak references.

# Interaction with C APIs

We do not use `vm_ptr` with C APIs. So far `unique_ptr` plus our own
hacked up `out_ptr` have sufficed.

# Pass by Pointer

Passing a pointer generates better code than passing a smart pointer
by reference. With this pass-by-pointer pattern, intrusive smart
pointers should retain by default and should provide `operator=(T *)`.

(For brevity, the following example code uses `struct` instead of
`class` and may leave out a few `const`s.)

Say we have:

<xmp>
#include <cstdio>
#include <string>

using namespace std;

struct Scout {
  virtual const char* Name() { return "Sam"; }
};
</xmp>

And a function that takes a pointer:

<xmp>
void greet(Scout* scout)
{
  printf("Hello %s", scout->Name());
}
</xmp>

Which will generate the following code (with `-Os`, but the argument
holds for `-O3` as well):


```
 1 greet(Scout*):
 2         subq    $8, %rsp
 3         movq    (%rdi), %rax
 4         call    *(%rax)
 5         popq    %rdx
 6         movq    %rax, %rsi
 7         movl    $.LC0, %edi
 8         xorl    %eax, %eax
 9         jmp     printf
```

Now look at a function that takes a `const retain_ptr&`:

<xmp>
void greet(const retain_ptr<Scout>& scout)
{
  printf("Hello %s", scout->Name());
}
</xmp>

It will generate:

```
 1 greet(const retain_ptr<Scout>&):
 2         subq    $8, %rsp
 3         movq    (%rdi), %rdi   <--- HERE
 4         movq    (%rdi), %rax
 5         call    *(%rax)
 6         popq    %rdx
 7         movq    %rax, %rsi
 8         movl    $.LC0, %edi
 9         xorl    %eax, %eax
10         jmp     printf
```

Look at line 3. We have an additional indirect load.

This might seem like a small thing, but it will add up in a large
codebase.

## Extrapolating from there

If we should always pass by pointer, then getters should return by
pointer too:

<xmp>
struct Expedition {
  Scout* getScout() { return scout_.get(); }
  retain_ptr<Scout> scout_;
};

void start()
{
  Expedition journeyEast;
  greet(journeyEast.getScout());  // As opposed to getScout().get().
}
</xmp>

Of course the `Scout*`'s lifetime is scoped to `journeyEast`'s
lifetime. While we currently rely on code review and Address Sanitizer
to defend against dangling pointers. We hope that we will have better
lifetime checking in the future. See the [Core Guidelines Lifetime
profile](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf).

## Retaining arguments

When we want to retain a result or a passed in argument `operator=`
is the natural tool to use:

<xmp>
struct Expedition {
  ...
  void setScout(Scout* scout) { scout_ = scout; }   // operatpr=
  ...
};

static retain_ptr<Scout> sCave;
void exploreCave(Expedition& e)
{
  sCave = e.getScout();                             // operator=
  e.setScout(nullptr);
}
</xmp>

## `adopt` / `release` still required

Of course we still need the ability to "adopt" and [[P1132R1]]
`out_ptr` helps us here:

<xmp>

extern void Adventure_CreateScout(Scout**);

retain_ptr<Scout> recruit()
{
  retain_ptr<Scout> scout;
  Adventure_CreateScout(std::out_ptr(scout, adopt_object_t()));
  return scout;
}
</xmp>

Adoption is typically only used at the interface with "C" APIs,
and should be less frequent than parameter passing and result
returning.

<pre class=biblio>
{
    "lifetime": {
        "title": "Lifetime safety: Preventing common dangling",
        "authors": ["Herb Sutter"],
        "date": "25 September 2018"
    }
}
</pre>
